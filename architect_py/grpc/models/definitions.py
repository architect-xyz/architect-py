# generated by datamodel-codegen:
#   filename:  definitions.json

from __future__ import annotations
from architect_py.common_types import OrderDir
from datetime import datetime, timezone

from datetime import date, datetime, time
from decimal import Decimal
from enum import Enum
from typing import Annotated, Dict, List, Literal, Optional, Union

from msgspec import Meta, Struct

from .Marketdata.Ticker import Ticker


AccountIdOrName = str


class AccountPosition(Struct, omit_defaults=True):
    quantity: Decimal
    break_even_price: Optional[Decimal] = None
    cost_basis: Optional[
        Annotated[
            Optional[Decimal], Meta(description="Cost basis of the position, if known.")
        ]
    ] = None
    """
    Cost basis of the position, if known.
    """
    liquidation_price: Optional[Decimal] = None
    trade_time: Optional[
        Annotated[
            Optional[datetime],
            Meta(description="NB: the meaning of this field varies by reporting venue"),
        ]
    ] = None
    """
    NB: the meaning of this field varies by reporting venue
    """
    unrealized_pnl: Optional[
        Annotated[
            Optional[Decimal],
            Meta(description="Unrealized PNL of the position, if known."),
        ]
    ] = None
    """
    Unrealized PNL of the position, if known.
    """

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        quantity: Decimal,
        break_even_price: Optional[Decimal] = None,
        cost_basis: Optional[Decimal] = None,
        liquidation_price: Optional[Decimal] = None,
        trade_time: Optional[datetime] = None,
        unrealized_pnl: Optional[Decimal] = None,
    ):
        return cls(
            quantity,
            break_even_price,
            cost_basis,
            liquidation_price,
            trade_time,
            unrealized_pnl,
        )

    def __str__(self) -> str:
        return f"AccountPosition(quantity={self.quantity},break_even_price={self.break_even_price},cost_basis={self.cost_basis},liquidation_price={self.liquidation_price},trade_time={self.trade_time},unrealized_pnl={self.unrealized_pnl})"


class AccountStatistics(Struct, omit_defaults=True):
    cash_excess: Optional[
        Annotated[Optional[Decimal], Meta(description="Cash available to withdraw.")]
    ] = None
    """
    Cash available to withdraw.
    """
    equity: Optional[
        Annotated[
            Optional[Decimal],
            Meta(description="Total account equity; net liquidation value."),
        ]
    ] = None
    """
    Total account equity; net liquidation value.
    """
    position_margin: Optional[
        Annotated[
            Optional[Decimal],
            Meta(description="Margin requirement based on current positions only."),
        ]
    ] = None
    """
    Margin requirement based on current positions only.
    """
    purchasing_power: Optional[
        Annotated[
            Optional[Decimal],
            Meta(
                description="Total purchasing power; post-multiplied. (e.g. for cash margin account could be 2x available cash)"
            ),
        ]
    ] = None
    """
    Total purchasing power; post-multiplied. (e.g. for cash margin account could be 2x available cash)
    """
    realized_pnl: Optional[Decimal] = None
    total_margin: Optional[
        Annotated[
            Optional[Decimal],
            Meta(
                description="Margin requirement calculated for worst-case based on open positions and working orders."
            ),
        ]
    ] = None
    """
    Margin requirement calculated for worst-case based on open positions and working orders.
    """
    unrealized_pnl: Optional[Decimal] = None
    yesterday_equity: Optional[
        Annotated[
            Optional[Decimal], Meta(description="Yesterday total account equity.")
        ]
    ] = None
    """
    Yesterday total account equity.
    """

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        cash_excess: Optional[Decimal] = None,
        equity: Optional[Decimal] = None,
        position_margin: Optional[Decimal] = None,
        purchasing_power: Optional[Decimal] = None,
        realized_pnl: Optional[Decimal] = None,
        total_margin: Optional[Decimal] = None,
        unrealized_pnl: Optional[Decimal] = None,
        yesterday_equity: Optional[Decimal] = None,
    ):
        return cls(
            cash_excess,
            equity,
            position_margin,
            purchasing_power,
            realized_pnl,
            total_margin,
            unrealized_pnl,
            yesterday_equity,
        )

    def __str__(self) -> str:
        return f"AccountStatistics(cash_excess={self.cash_excess},equity={self.equity},position_margin={self.position_margin},purchasing_power={self.purchasing_power},realized_pnl={self.realized_pnl},total_margin={self.total_margin},unrealized_pnl={self.unrealized_pnl},yesterday_equity={self.yesterday_equity})"


class AlgoOrderStatus(int, Enum):
    Working = 1
    Rejected = 2
    Paused = 63
    Stopped = 127


class CancelStatus(int, Enum):
    Pending = 0
    Acked = 1
    Rejected = 2
    Out = 127


class CandleWidth(int, Enum):
    OneSecond = 1
    FiveSecond = 5
    OneMinute = 60
    FifteenMinute = 900
    OneHour = 3600
    OneDay = 86400


class ConnectionStatus(Struct, omit_defaults=True):
    connected: bool
    last_heartbeat: Annotated[int, Meta(description="UNIX epoch time or -1 for never")]
    """
    UNIX epoch time or -1 for never
    """
    last_heartbeat_stale_threshold: Annotated[
        int, Meta(description="Stale threshold in seconds, or -1 for never stale")
    ]
    """
    Stale threshold in seconds, or -1 for never stale
    """
    logged_in: Optional[
        Annotated[
            Optional[bool], Meta(description="Not applicable to connection if None")
        ]
    ] = None
    """
    Not applicable to connection if None
    """

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        connected: bool,
        last_heartbeat: int,
        last_heartbeat_stale_threshold: int,
        logged_in: Optional[bool] = None,
    ):
        return cls(
            connected,
            last_heartbeat,
            last_heartbeat_stale_threshold,
            logged_in,
        )

    def __str__(self) -> str:
        return f"ConnectionStatus(connected={self.connected},last_heartbeat={self.last_heartbeat},last_heartbeat_stale_threshold={self.last_heartbeat_stale_threshold},logged_in={self.logged_in})"


class CptyLogoutRequest(Struct, omit_defaults=True):
    pass

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
    ):
        return cls()

    def __str__(self) -> str:
        return f"CptyLogoutRequest()"


DateTimeOrUtc = datetime


class Deposit(Struct, omit_defaults=True):
    account: str
    amount: Decimal
    description: str
    timestamp: datetime

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        account: str,
        amount: Decimal,
        description: str,
        timestamp: datetime,
    ):
        return cls(
            account,
            amount,
            description,
            timestamp,
        )

    def __str__(self) -> str:
        return f"Deposit(account={self.account},amount={self.amount},description={self.description},timestamp={self.timestamp})"


class HealthMetric(Struct, omit_defaults=True):
    timestamp: int
    value: float
    should_be_greater_than: Optional[float] = None
    should_be_greater_than_or_equal_to: Optional[float] = None
    should_be_less_than: Optional[float] = None
    should_be_less_than_or_equal_to: Optional[float] = None

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        timestamp: int,
        value: float,
        should_be_greater_than: Optional[float] = None,
        should_be_greater_than_or_equal_to: Optional[float] = None,
        should_be_less_than: Optional[float] = None,
        should_be_less_than_or_equal_to: Optional[float] = None,
    ):
        return cls(
            timestamp,
            value,
            should_be_greater_than,
            should_be_greater_than_or_equal_to,
            should_be_less_than,
            should_be_less_than_or_equal_to,
        )

    def __str__(self) -> str:
        return f"HealthMetric(timestamp={self.timestamp},value={self.value},should_be_greater_than={self.should_be_greater_than},should_be_greater_than_or_equal_to={self.should_be_greater_than_or_equal_to},should_be_less_than={self.should_be_less_than},should_be_less_than_or_equal_to={self.should_be_less_than_or_equal_to})"


class HealthStatus(str, Enum):
    UNKNOWN = "UNKNOWN"
    SERVING = "SERVING"
    NOT_SERVING = "NOT_SERVING"
    SERVICE_UNKNOWN = "SERVICE_UNKNOWN"


Ask = List[Decimal]


Bid = List[Decimal]


class L2BookDiff(Struct, omit_defaults=True):
    """
    Unique sequence id and number.
    """

    a: Annotated[
        List[Ask],
        Meta(
            description="Set of (price, level) updates. If zero, the price level has been removed from the book.",
            title="asks",
        ),
    ]
    """
    Set of (price, level) updates. If zero, the price level has been removed from the book.
    """
    b: Annotated[
        List[Bid],
        Meta(
            description="Set of (price, level) updates. If zero, the price level has been removed from the book.",
            title="bids",
        ),
    ]
    """
    Set of (price, level) updates. If zero, the price level has been removed from the book.
    """
    sid: Annotated[int, Meta(ge=0, title="sequence_id")]
    sn: Annotated[int, Meta(ge=0, title="sequence_number")]
    tn: Annotated[int, Meta(ge=0, title="timestamp_ns")]
    ts: Annotated[int, Meta(title="timestamp")]

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        asks: List[Ask],
        bids: List[Bid],
        sequence_id: int,
        sequence_number: int,
        timestamp_ns: int,
        timestamp: int,
    ):
        return cls(
            asks,
            bids,
            sequence_id,
            sequence_number,
            timestamp_ns,
            timestamp,
        )

    def __str__(self) -> str:
        return f"L2BookDiff(asks={self.a},bids={self.b},sequence_id={self.sid},sequence_number={self.sn},timestamp_ns={self.tn},timestamp={self.ts})"

    @property
    def asks(self) -> List[Ask]:
        return self.a

    @asks.setter
    def asks(self, value: List[Ask]) -> None:
        self.a = value

    @property
    def bids(self) -> List[Bid]:
        return self.b

    @bids.setter
    def bids(self, value: List[Bid]) -> None:
        self.b = value

    @property
    def sequence_id(self) -> int:
        return self.sid

    @sequence_id.setter
    def sequence_id(self, value: int) -> None:
        self.sid = value

    @property
    def sequence_number(self) -> int:
        return self.sn

    @sequence_number.setter
    def sequence_number(self, value: int) -> None:
        self.sn = value

    @property
    def timestamp_ns(self) -> int:
        return self.tn

    @timestamp_ns.setter
    def timestamp_ns(self, value: int) -> None:
        self.tn = value

    @property
    def timestamp(self) -> int:
        return self.ts

    @timestamp.setter
    def timestamp(self, value: int) -> None:
        self.ts = value

    @property
    def datetime(self) -> datetime:
        return datetime.fromtimestamp(self.ts, tz=timezone.utc)

    @property
    def datetime_local(self) -> datetime:
        return datetime.fromtimestamp(self.ts)


OrderId = Annotated[
    str, Meta(description="System-unique, persistent order identifiers")
]


class OrderOut(Struct, omit_defaults=True):
    id: OrderId

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        id: OrderId,
    ):
        return cls(
            id,
        )

    def __str__(self) -> str:
        return f"OrderOut(id={self.id})"


class OrderRejectReason(str, Enum):
    DuplicateOrderId = "DuplicateOrderId"
    NotAuthorized = "NotAuthorized"
    NoExecutionVenue = "NoExecutionVenue"
    NoAccount = "NoAccount"
    NoCpty = "NoCpty"
    UnsupportedOrderType = "UnsupportedOrderType"
    UnsupportedExecutionVenue = "UnsupportedExecutionVenue"
    InsufficientCash = "InsufficientCash"
    InsufficientMargin = "InsufficientMargin"
    NotEasyToBorrow = "NotEasyToBorrow"
    InvalidOrder = "InvalidOrder"
    Unknown = "Unknown"


class OrderSource(int, Enum):
    API = 0
    GUI = 1
    Algo = 2
    Reconciled = 3
    CLI = 4
    Telegram = 5
    Other = 255


class OrderStale(Struct, omit_defaults=True):
    id: OrderId

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        id: OrderId,
    ):
        return cls(
            id,
        )

    def __str__(self) -> str:
        return f"OrderStale(id={self.id})"


class OrderStatus(int, Enum):
    Pending = 0
    Open = 1
    Rejected = 2
    Out = 127
    Canceling = 128
    Canceled = 129
    ReconciledOut = 130
    Stale = 254
    Unknown = 255


class OrderType(str, Enum):
    MARKET = "MARKET"
    LIMIT = "LIMIT"
    STOP_LOSS_LIMIT = "STOP_LOSS_LIMIT"
    TAKE_PROFIT_LIMIT = "TAKE_PROFIT_LIMIT"


class ProductCatalogInfo(Struct, omit_defaults=True):
    """
    Loosely normalized information about exchange products; used to seed symbology loaders and populate extended product info;

    Symbology loaders will use catalog fields to augment and/or cross-check any other load source.
    """

    exchange: str
    exchange_product: Annotated[str, Meta(description="Could be anything really")]
    """
    Could be anything really
    """
    category: Optional[str] = None
    cqg_contract_symbol: Optional[str] = None
    info_url: Optional[
        Annotated[Optional[str], Meta(description="URL to more product info")]
    ] = None
    """
    URL to more product info
    """
    long_description: Optional[str] = None
    multiplier: Optional[
        Annotated[
            Optional[Decimal],
            Meta(description="For derivatives contracts, the multiplier"),
        ]
    ] = None
    """
    For derivatives contracts, the multiplier
    """
    price_display_format: Optional[str] = None
    quote_currency: Optional[str] = None
    schedule_description: Optional[str] = None
    settle_method: Optional[str] = None
    short_description: Optional[
        Annotated[
            Optional[str],
            Meta(
                description="Short description of the product, suitable for display in a bubble, for example"
            ),
        ]
    ] = None
    """
    Short description of the product, suitable for display in a bubble, for example
    """
    sub_category: Optional[str] = None

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        exchange: str,
        exchange_product: str,
        category: Optional[str] = None,
        cqg_contract_symbol: Optional[str] = None,
        info_url: Optional[str] = None,
        long_description: Optional[str] = None,
        multiplier: Optional[Decimal] = None,
        price_display_format: Optional[str] = None,
        quote_currency: Optional[str] = None,
        schedule_description: Optional[str] = None,
        settle_method: Optional[str] = None,
        short_description: Optional[str] = None,
        sub_category: Optional[str] = None,
    ):
        return cls(
            exchange,
            exchange_product,
            category,
            cqg_contract_symbol,
            info_url,
            long_description,
            multiplier,
            price_display_format,
            quote_currency,
            schedule_description,
            settle_method,
            short_description,
            sub_category,
        )

    def __str__(self) -> str:
        return f"ProductCatalogInfo(exchange={self.exchange},exchange_product={self.exchange_product},category={self.category},cqg_contract_symbol={self.cqg_contract_symbol},info_url={self.info_url},long_description={self.long_description},multiplier={self.multiplier},price_display_format={self.price_display_format},quote_currency={self.quote_currency},schedule_description={self.schedule_description},settle_method={self.settle_method},short_description={self.short_description},sub_category={self.sub_category})"


class RqdAccountStatistics(Struct, omit_defaults=True):
    account_number: str
    account_type: Optional[str] = None
    as_of_date: Optional[str] = None
    available_cash_balance: Optional[Decimal] = None
    cash_available_for_withdrawal: Optional[Decimal] = None
    cumulative_day_trade_pnl: Optional[Decimal] = None
    day_trading_buying_power: Optional[Decimal] = None
    day_trading_buying_power_high_water_mark: Optional[Decimal] = None
    day_trading_buying_power_maintenance_margin_multiplier: Optional[Decimal] = None
    day_trading_house_minimum_equity_margin_call_amount: Optional[Decimal] = None
    day_trading_margin_call_amount: Optional[Decimal] = None
    day_trading_minimum_equity_margin_call_amount: Optional[Decimal] = None
    excess_sma_amount: Optional[Decimal] = None
    house_initial_margin_requirement_adjustment_factor: Optional[Decimal] = None
    house_margin_call_amount: Optional[Decimal] = None
    house_margin_requirement: Optional[Decimal] = None
    house_margin_requirement_adjustment_factor: Optional[Decimal] = None
    is_day_trader: Optional[str] = None
    maintenance_margin_requirement: Optional[Decimal] = None
    margin_call_amount: Optional[Decimal] = None
    marginable_equity: Optional[Decimal] = None
    market_value_adjustment_factor: Optional[Decimal] = None
    number_open_day_trading_margin_calls: Optional[Decimal] = None
    option_only_maintenance_margin_requirement: Optional[Decimal] = None
    option_trade_date_short_market_value: Optional[Decimal] = None
    overall_current_sma_balance: Optional[Decimal] = None
    overnight_buying_power: Optional[Decimal] = None
    reg_t_initial_margin_requirement: Optional[Decimal] = None
    reg_t_maintenance_margin_requirement_adjustment_factor: Optional[str] = None
    reg_t_margin_call_amount: Optional[Decimal] = None
    settlement_date_cash_balance: Optional[Decimal] = None
    settlement_date_long_market_value: Optional[Decimal] = None
    settlement_date_option_long_market_value: Optional[Decimal] = None
    settlement_date_option_short_market_value: Optional[Decimal] = None
    settlement_date_short_market_value: Optional[Decimal] = None
    start_of_day_day_trading_buying_power: Optional[Decimal] = None
    start_of_day_day_trading_buying_power_margin_call_amount: Optional[Decimal] = None
    start_of_day_house_margin_call_amount: Optional[Decimal] = None
    start_of_day_maintenance_margin_call_amount: Optional[Decimal] = None
    start_of_day_reg_t_margin_call_amount: Optional[Decimal] = None
    strategy_based_relief_adjustment_factor: Optional[Decimal] = None
    total_equity: Optional[Decimal] = None
    trade_date_cash_balance: Optional[Decimal] = None
    trade_date_option_long_market_value: Optional[Decimal] = None
    trade_date_total_long_market_value: Optional[Decimal] = None
    trade_date_total_short_market_value: Optional[Decimal] = None
    usable_sma_balance: Optional[Decimal] = None

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        account_number: str,
        account_type: Optional[str] = None,
        as_of_date: Optional[str] = None,
        available_cash_balance: Optional[Decimal] = None,
        cash_available_for_withdrawal: Optional[Decimal] = None,
        cumulative_day_trade_pnl: Optional[Decimal] = None,
        day_trading_buying_power: Optional[Decimal] = None,
        day_trading_buying_power_high_water_mark: Optional[Decimal] = None,
        day_trading_buying_power_maintenance_margin_multiplier: Optional[
            Decimal
        ] = None,
        day_trading_house_minimum_equity_margin_call_amount: Optional[Decimal] = None,
        day_trading_margin_call_amount: Optional[Decimal] = None,
        day_trading_minimum_equity_margin_call_amount: Optional[Decimal] = None,
        excess_sma_amount: Optional[Decimal] = None,
        house_initial_margin_requirement_adjustment_factor: Optional[Decimal] = None,
        house_margin_call_amount: Optional[Decimal] = None,
        house_margin_requirement: Optional[Decimal] = None,
        house_margin_requirement_adjustment_factor: Optional[Decimal] = None,
        is_day_trader: Optional[str] = None,
        maintenance_margin_requirement: Optional[Decimal] = None,
        margin_call_amount: Optional[Decimal] = None,
        marginable_equity: Optional[Decimal] = None,
        market_value_adjustment_factor: Optional[Decimal] = None,
        number_open_day_trading_margin_calls: Optional[Decimal] = None,
        option_only_maintenance_margin_requirement: Optional[Decimal] = None,
        option_trade_date_short_market_value: Optional[Decimal] = None,
        overall_current_sma_balance: Optional[Decimal] = None,
        overnight_buying_power: Optional[Decimal] = None,
        reg_t_initial_margin_requirement: Optional[Decimal] = None,
        reg_t_maintenance_margin_requirement_adjustment_factor: Optional[str] = None,
        reg_t_margin_call_amount: Optional[Decimal] = None,
        settlement_date_cash_balance: Optional[Decimal] = None,
        settlement_date_long_market_value: Optional[Decimal] = None,
        settlement_date_option_long_market_value: Optional[Decimal] = None,
        settlement_date_option_short_market_value: Optional[Decimal] = None,
        settlement_date_short_market_value: Optional[Decimal] = None,
        start_of_day_day_trading_buying_power: Optional[Decimal] = None,
        start_of_day_day_trading_buying_power_margin_call_amount: Optional[
            Decimal
        ] = None,
        start_of_day_house_margin_call_amount: Optional[Decimal] = None,
        start_of_day_maintenance_margin_call_amount: Optional[Decimal] = None,
        start_of_day_reg_t_margin_call_amount: Optional[Decimal] = None,
        strategy_based_relief_adjustment_factor: Optional[Decimal] = None,
        total_equity: Optional[Decimal] = None,
        trade_date_cash_balance: Optional[Decimal] = None,
        trade_date_option_long_market_value: Optional[Decimal] = None,
        trade_date_total_long_market_value: Optional[Decimal] = None,
        trade_date_total_short_market_value: Optional[Decimal] = None,
        usable_sma_balance: Optional[Decimal] = None,
    ):
        return cls(
            account_number,
            account_type,
            as_of_date,
            available_cash_balance,
            cash_available_for_withdrawal,
            cumulative_day_trade_pnl,
            day_trading_buying_power,
            day_trading_buying_power_high_water_mark,
            day_trading_buying_power_maintenance_margin_multiplier,
            day_trading_house_minimum_equity_margin_call_amount,
            day_trading_margin_call_amount,
            day_trading_minimum_equity_margin_call_amount,
            excess_sma_amount,
            house_initial_margin_requirement_adjustment_factor,
            house_margin_call_amount,
            house_margin_requirement,
            house_margin_requirement_adjustment_factor,
            is_day_trader,
            maintenance_margin_requirement,
            margin_call_amount,
            marginable_equity,
            market_value_adjustment_factor,
            number_open_day_trading_margin_calls,
            option_only_maintenance_margin_requirement,
            option_trade_date_short_market_value,
            overall_current_sma_balance,
            overnight_buying_power,
            reg_t_initial_margin_requirement,
            reg_t_maintenance_margin_requirement_adjustment_factor,
            reg_t_margin_call_amount,
            settlement_date_cash_balance,
            settlement_date_long_market_value,
            settlement_date_option_long_market_value,
            settlement_date_option_short_market_value,
            settlement_date_short_market_value,
            start_of_day_day_trading_buying_power,
            start_of_day_day_trading_buying_power_margin_call_amount,
            start_of_day_house_margin_call_amount,
            start_of_day_maintenance_margin_call_amount,
            start_of_day_reg_t_margin_call_amount,
            strategy_based_relief_adjustment_factor,
            total_equity,
            trade_date_cash_balance,
            trade_date_option_long_market_value,
            trade_date_total_long_market_value,
            trade_date_total_short_market_value,
            usable_sma_balance,
        )

    def __str__(self) -> str:
        return f"RqdAccountStatistics(account_number={self.account_number},account_type={self.account_type},as_of_date={self.as_of_date},available_cash_balance={self.available_cash_balance},cash_available_for_withdrawal={self.cash_available_for_withdrawal},cumulative_day_trade_pnl={self.cumulative_day_trade_pnl},day_trading_buying_power={self.day_trading_buying_power},day_trading_buying_power_high_water_mark={self.day_trading_buying_power_high_water_mark},day_trading_buying_power_maintenance_margin_multiplier={self.day_trading_buying_power_maintenance_margin_multiplier},day_trading_house_minimum_equity_margin_call_amount={self.day_trading_house_minimum_equity_margin_call_amount},day_trading_margin_call_amount={self.day_trading_margin_call_amount},day_trading_minimum_equity_margin_call_amount={self.day_trading_minimum_equity_margin_call_amount},excess_sma_amount={self.excess_sma_amount},house_initial_margin_requirement_adjustment_factor={self.house_initial_margin_requirement_adjustment_factor},house_margin_call_amount={self.house_margin_call_amount},house_margin_requirement={self.house_margin_requirement},house_margin_requirement_adjustment_factor={self.house_margin_requirement_adjustment_factor},is_day_trader={self.is_day_trader},maintenance_margin_requirement={self.maintenance_margin_requirement},margin_call_amount={self.margin_call_amount},marginable_equity={self.marginable_equity},market_value_adjustment_factor={self.market_value_adjustment_factor},number_open_day_trading_margin_calls={self.number_open_day_trading_margin_calls},option_only_maintenance_margin_requirement={self.option_only_maintenance_margin_requirement},option_trade_date_short_market_value={self.option_trade_date_short_market_value},overall_current_sma_balance={self.overall_current_sma_balance},overnight_buying_power={self.overnight_buying_power},reg_t_initial_margin_requirement={self.reg_t_initial_margin_requirement},reg_t_maintenance_margin_requirement_adjustment_factor={self.reg_t_maintenance_margin_requirement_adjustment_factor},reg_t_margin_call_amount={self.reg_t_margin_call_amount},settlement_date_cash_balance={self.settlement_date_cash_balance},settlement_date_long_market_value={self.settlement_date_long_market_value},settlement_date_option_long_market_value={self.settlement_date_option_long_market_value},settlement_date_option_short_market_value={self.settlement_date_option_short_market_value},settlement_date_short_market_value={self.settlement_date_short_market_value},start_of_day_day_trading_buying_power={self.start_of_day_day_trading_buying_power},start_of_day_day_trading_buying_power_margin_call_amount={self.start_of_day_day_trading_buying_power_margin_call_amount},start_of_day_house_margin_call_amount={self.start_of_day_house_margin_call_amount},start_of_day_maintenance_margin_call_amount={self.start_of_day_maintenance_margin_call_amount},start_of_day_reg_t_margin_call_amount={self.start_of_day_reg_t_margin_call_amount},strategy_based_relief_adjustment_factor={self.strategy_based_relief_adjustment_factor},total_equity={self.total_equity},trade_date_cash_balance={self.trade_date_cash_balance},trade_date_option_long_market_value={self.trade_date_option_long_market_value},trade_date_total_long_market_value={self.trade_date_total_long_market_value},trade_date_total_short_market_value={self.trade_date_total_short_market_value},usable_sma_balance={self.usable_sma_balance})"


class SortTickersBy(str, Enum):
    VOLUME_DESC = "VOLUME_DESC"
    CHANGE_ASC = "CHANGE_ASC"
    CHANGE_DESC = "CHANGE_DESC"
    ABS_CHANGE_DESC = "ABS_CHANGE_DESC"


class Statement(Struct, omit_defaults=True):
    account: str
    clearing_firm: str
    filename: str
    statement_date: date
    statement_type: str
    statement_uuid: str

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        account: str,
        clearing_firm: str,
        filename: str,
        statement_date: date,
        statement_type: str,
        statement_uuid: str,
    ):
        return cls(
            account,
            clearing_firm,
            filename,
            statement_date,
            statement_type,
            statement_uuid,
        )

    def __str__(self) -> str:
        return f"Statement(account={self.account},clearing_firm={self.clearing_firm},filename={self.filename},statement_date={self.statement_date},statement_type={self.statement_type},statement_uuid={self.statement_uuid})"


TraderIdOrEmail = str


UserId = str


class Withdrawal(Struct, omit_defaults=True):
    account: str
    amount: Decimal
    description: str
    timestamp: datetime

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        account: str,
        amount: Decimal,
        description: str,
        timestamp: datetime,
    ):
        return cls(
            account,
            amount,
            description,
            timestamp,
        )

    def __str__(self) -> str:
        return f"Withdrawal(account={self.account},amount={self.amount},description={self.description},timestamp={self.timestamp})"


class AccountPermissions(Struct, omit_defaults=True):
    """
    Set of flags for account permissions
    """

    list: bool
    reduce_or_close: bool
    set_limits: bool
    trade: bool
    view: bool

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        list: bool,
        reduce_or_close: bool,
        set_limits: bool,
        trade: bool,
        view: bool,
    ):
        return cls(
            list,
            reduce_or_close,
            set_limits,
            trade,
            view,
        )

    def __str__(self) -> str:
        return f"AccountPermissions(list={self.list},reduce_or_close={self.reduce_or_close},set_limits={self.set_limits},trade={self.trade},view={self.view})"


class AliasKind(str, Enum):
    CME_GLOBEX = "CME_GLOBEX"
    CFE = "CFE"


class DerivativeKind(str, Enum):
    Linear = "Linear"
    Inverse = "Inverse"
    Quanto = "Quanto"


class FillKind(int, Enum):
    Normal = 0
    Reversal = 1
    Correction = 2


class Unit(str, Enum):
    base = "base"
    quote = "quote"


class MinOrderQuantityUnit(Struct, omit_defaults=True):
    unit: Unit

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        unit: Unit,
    ):
        return cls(
            unit,
        )

    def __str__(self) -> str:
        return f"MinOrderQuantityUnit(unit={self.unit})"


class OptionsExerciseType(str, Enum):
    american = "american"
    european = "european"
    unknown = "unknown"


PriceDisplayFormat = str


class Fiat(Struct, omit_defaults=True):
    product_type: Literal["Fiat"]

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        product_type: Literal["Fiat"],
    ):
        return cls(
            product_type,
        )

    def __str__(self) -> str:
        return f"Fiat(product_type={self.product_type})"


class Commodity(Struct, omit_defaults=True):
    product_type: Literal["Commodity"]

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        product_type: Literal["Commodity"],
    ):
        return cls(
            product_type,
        )

    def __str__(self) -> str:
        return f"Commodity(product_type={self.product_type})"


class Crypto(Struct, omit_defaults=True):
    product_type: Literal["Crypto"]

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        product_type: Literal["Crypto"],
    ):
        return cls(
            product_type,
        )

    def __str__(self) -> str:
        return f"Crypto(product_type={self.product_type})"


class Equity(Struct, omit_defaults=True):
    product_type: Literal["Equity"]
    easy_to_borrow: Optional[bool] = None

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        product_type: Literal["Equity"],
        easy_to_borrow: Optional[bool] = None,
    ):
        return cls(
            product_type,
            easy_to_borrow,
        )

    def __str__(self) -> str:
        return f"Equity(product_type={self.product_type},easy_to_borrow={self.easy_to_borrow})"


class Index(Struct, omit_defaults=True):
    product_type: Literal["Index"]

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        product_type: Literal["Index"],
    ):
        return cls(
            product_type,
        )

    def __str__(self) -> str:
        return f"Index(product_type={self.product_type})"


class Future(Struct, omit_defaults=True):
    derivative_kind: DerivativeKind
    expiration: datetime
    multiplier: Decimal
    product_type: Literal["Future"]
    first_notice_date: Optional[date] = None
    series: Optional[str] = None
    underlying: Optional[str] = None

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        derivative_kind: DerivativeKind,
        expiration: datetime,
        multiplier: Decimal,
        product_type: Literal["Future"],
        first_notice_date: Optional[date] = None,
        series: Optional[str] = None,
        underlying: Optional[str] = None,
    ):
        return cls(
            derivative_kind,
            expiration,
            multiplier,
            product_type,
            first_notice_date,
            series,
            underlying,
        )

    def __str__(self) -> str:
        return f"Future(derivative_kind={self.derivative_kind},expiration={self.expiration},multiplier={self.multiplier},product_type={self.product_type},first_notice_date={self.first_notice_date},series={self.series},underlying={self.underlying})"


class Perpetual(Struct, omit_defaults=True):
    derivative_kind: DerivativeKind
    multiplier: Decimal
    product_type: Literal["Perpetual"]
    underlying: Optional[str] = None

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        derivative_kind: DerivativeKind,
        multiplier: Decimal,
        product_type: Literal["Perpetual"],
        underlying: Optional[str] = None,
    ):
        return cls(
            derivative_kind,
            multiplier,
            product_type,
            underlying,
        )

    def __str__(self) -> str:
        return f"Perpetual(derivative_kind={self.derivative_kind},multiplier={self.multiplier},product_type={self.product_type},underlying={self.underlying})"


class Unknown(Struct, omit_defaults=True):
    product_type: Literal["Unknown"]

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        product_type: Literal["Unknown"],
    ):
        return cls(
            product_type,
        )

    def __str__(self) -> str:
        return f"Unknown(product_type={self.product_type})"


class PutOrCall(str, Enum):
    P = "P"
    C = "C"


class SnapshotOrUpdateForStringAndProductCatalogInfo1(Struct, omit_defaults=True):
    snapshot: Dict[str, ProductCatalogInfo]

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        snapshot: Dict[str, ProductCatalogInfo],
    ):
        return cls(
            snapshot,
        )

    def __str__(self) -> str:
        return (
            f"SnapshotOrUpdateForStringAndProductCatalogInfo1(snapshot={self.snapshot})"
        )


Update6 = List[Union[str, Optional[ProductCatalogInfo]]]


class SnapshotOrUpdateForStringAndProductCatalogInfo2(Struct, omit_defaults=True):
    updates: List[Update6]

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        updates: List[Update6],
    ):
        return cls(
            updates,
        )

    def __str__(self) -> str:
        return (
            f"SnapshotOrUpdateForStringAndProductCatalogInfo2(updates={self.updates})"
        )


SnapshotOrUpdateForStringAndProductCatalogInfo = Union[
    SnapshotOrUpdateForStringAndProductCatalogInfo1,
    SnapshotOrUpdateForStringAndProductCatalogInfo2,
]


class SnapshotOrUpdateForStringAndString1(Struct, omit_defaults=True):
    snapshot: Dict[str, str]

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        snapshot: Dict[str, str],
    ):
        return cls(
            snapshot,
        )

    def __str__(self) -> str:
        return f"SnapshotOrUpdateForStringAndString1(snapshot={self.snapshot})"


Update7 = List[Union[str, Optional[str]]]


class SnapshotOrUpdateForStringAndString2(Struct, omit_defaults=True):
    updates: List[Update7]

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        updates: List[Update7],
    ):
        return cls(
            updates,
        )

    def __str__(self) -> str:
        return f"SnapshotOrUpdateForStringAndString2(updates={self.updates})"


SnapshotOrUpdateForStringAndString = Union[
    SnapshotOrUpdateForStringAndString1, SnapshotOrUpdateForStringAndString2
]


class SimpleDecimal(Struct, omit_defaults=True):
    simple: Decimal

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        simple: Decimal,
    ):
        return cls(
            simple,
        )

    def __str__(self) -> str:
        return f"SimpleDecimal(simple={self.simple})"


Threshold = List[Decimal]


class Varying1(Struct, omit_defaults=True):
    thresholds: List[Threshold]

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        thresholds: List[Threshold],
    ):
        return cls(
            thresholds,
        )

    def __str__(self) -> str:
        return f"Varying1(thresholds={self.thresholds})"


class Varying(Struct, omit_defaults=True):
    """
    List of (threshold, tick_size) pairs.  For price greater than or equal to each threshold, the tick size is the corresponding value.
    """

    varying: Varying1

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        varying: Varying1,
    ):
        return cls(
            varying,
        )

    def __str__(self) -> str:
        return f"Varying(varying={self.varying})"


TickSize = Union[SimpleDecimal, Varying]


AccountName = str


class OptionLike(Struct, omit_defaults=True):
    strike: Decimal
    expiration: Optional[datetime] = None

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        strike: Decimal,
        expiration: Optional[datetime] = None,
    ):
        return cls(
            strike,
            expiration,
        )

    def __str__(self) -> str:
        return f"OptionLike(strike={self.strike},expiration={self.expiration})"


class EventContractSeriesInstance2(Struct, omit_defaults=True):
    OptionLike: OptionLike

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        OptionLike: OptionLike,
    ):
        return cls(
            OptionLike,
        )

    def __str__(self) -> str:
        return f"EventContractSeriesInstance2(OptionLike={self.OptionLike})"


class OptionsSeriesInstance(Struct, omit_defaults=True):
    """
    A specific option from a series.
    """

    expiration: datetime
    put_or_call: PutOrCall
    strike: Decimal

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        expiration: datetime,
        put_or_call: PutOrCall,
        strike: Decimal,
    ):
        return cls(
            expiration,
            put_or_call,
            strike,
        )

    def __str__(self) -> str:
        return f"OptionsSeriesInstance(expiration={self.expiration},put_or_call={self.put_or_call},strike={self.strike})"


class SpreadLeg(Struct, omit_defaults=True):
    product: str
    quantity: Annotated[
        Decimal,
        Meta(
            description="Some spreads have different ratios for their legs, like buy 1 A, sell 2 B, buy 1 C; We would represent that with quantities in the legs: 1, -2, 1"
        ),
    ]
    """
    Some spreads have different ratios for their legs, like buy 1 A, sell 2 B, buy 1 C; We would represent that with quantities in the legs: 1, -2, 1
    """

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        product: str,
        quantity: Decimal,
    ):
        return cls(
            product,
            quantity,
        )

    def __str__(self) -> str:
        return f"SpreadLeg(product={self.product},quantity={self.quantity})"


class Outcome(Struct, omit_defaults=True):
    name: str

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        name: str,
    ):
        return cls(
            name,
        )

    def __str__(self) -> str:
        return f"Outcome(name={self.name})"


class AberrantFill(Struct, omit_defaults=True):
    """
    Fills which we received but couldn't parse fully, return details best effort
    """

    id: Annotated[str, Meta(title="fill_id")]
    x: Annotated[str, Meta(title="execution_venue")]
    a: Optional[Annotated[Optional[str], Meta(title="account")]] = None
    atn: Optional[Annotated[Optional[int], Meta(title="recv_time_ns")]] = None
    ats: Optional[Annotated[Optional[int], Meta(title="recv_time")]] = None
    d: Optional[Annotated[Optional[OrderDir], Meta(title="dir")]] = None
    f: Optional[Annotated[Optional[Decimal], Meta(title="fee")]] = None
    fu: Optional[Annotated[Optional[str], Meta(title="fee_currency")]] = None
    k: Optional[Annotated[Optional[FillKind], Meta(title="fill_kind")]] = None
    oid: Optional[Annotated[Optional[OrderId], Meta(title="order_id")]] = None
    p: Optional[Annotated[Optional[Decimal], Meta(title="price")]] = None
    q: Optional[Annotated[Optional[Decimal], Meta(title="quantity")]] = None
    s: Optional[Annotated[Optional[str], Meta(title="symbol")]] = None
    tn: Optional[Annotated[Optional[int], Meta(title="trade_time_ns")]] = None
    ts: Optional[Annotated[Optional[int], Meta(title="trade_time")]] = None
    u: Optional[Annotated[Optional[UserId], Meta(title="trader")]] = None
    xid: Optional[Annotated[Optional[str], Meta(title="exchange_fill_id")]] = None

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        fill_id: str,
        execution_venue: str,
        account: Optional[str] = None,
        recv_time_ns: Optional[int] = None,
        recv_time: Optional[int] = None,
        dir: Optional[OrderDir] = None,
        fee: Optional[Decimal] = None,
        fee_currency: Optional[str] = None,
        fill_kind: Optional[FillKind] = None,
        order_id: Optional[OrderId] = None,
        price: Optional[Decimal] = None,
        quantity: Optional[Decimal] = None,
        symbol: Optional[str] = None,
        trade_time_ns: Optional[int] = None,
        trade_time: Optional[int] = None,
        trader: Optional[UserId] = None,
        exchange_fill_id: Optional[str] = None,
    ):
        return cls(
            fill_id,
            execution_venue,
            account,
            recv_time_ns,
            recv_time,
            dir,
            fee,
            fee_currency,
            fill_kind,
            order_id,
            price,
            quantity,
            symbol,
            trade_time_ns,
            trade_time,
            trader,
            exchange_fill_id,
        )

    def __str__(self) -> str:
        return f"AberrantFill(fill_id={self.id},execution_venue={self.x},account={self.a},recv_time_ns={self.atn},recv_time={self.ats},dir={self.d},fee={self.f},fee_currency={self.fu},fill_kind={self.k},order_id={self.oid},price={self.p},quantity={self.q},symbol={self.s},trade_time_ns={self.tn},trade_time={self.ts},trader={self.u},exchange_fill_id={self.xid})"

    @property
    def fill_id(self) -> str:
        return self.id

    @fill_id.setter
    def fill_id(self, value: str) -> None:
        self.id = value

    @property
    def execution_venue(self) -> str:
        return self.x

    @execution_venue.setter
    def execution_venue(self, value: str) -> None:
        self.x = value

    @property
    def account(self) -> Optional[str]:
        return self.a

    @account.setter
    def account(self, value: Optional[str]) -> None:
        self.a = value

    @property
    def recv_time_ns(self) -> Optional[int]:
        return self.atn

    @recv_time_ns.setter
    def recv_time_ns(self, value: Optional[int]) -> None:
        self.atn = value

    @property
    def recv_time(self) -> Optional[int]:
        return self.ats

    @recv_time.setter
    def recv_time(self, value: Optional[int]) -> None:
        self.ats = value

    @property
    def dir(self) -> Optional[OrderDir]:
        return self.d

    @dir.setter
    def dir(self, value: Optional[OrderDir]) -> None:
        self.d = value

    @property
    def fee(self) -> Optional[Decimal]:
        return self.f

    @fee.setter
    def fee(self, value: Optional[Decimal]) -> None:
        self.f = value

    @property
    def fee_currency(self) -> Optional[str]:
        return self.fu

    @fee_currency.setter
    def fee_currency(self, value: Optional[str]) -> None:
        self.fu = value

    @property
    def fill_kind(self) -> Optional[FillKind]:
        return self.k

    @fill_kind.setter
    def fill_kind(self, value: Optional[FillKind]) -> None:
        self.k = value

    @property
    def order_id(self) -> Optional[OrderId]:
        return self.oid

    @order_id.setter
    def order_id(self, value: Optional[OrderId]) -> None:
        self.oid = value

    @property
    def price(self) -> Optional[Decimal]:
        return self.p

    @price.setter
    def price(self, value: Optional[Decimal]) -> None:
        self.p = value

    @property
    def quantity(self) -> Optional[Decimal]:
        return self.q

    @quantity.setter
    def quantity(self, value: Optional[Decimal]) -> None:
        self.q = value

    @property
    def symbol(self) -> Optional[str]:
        return self.s

    @symbol.setter
    def symbol(self, value: Optional[str]) -> None:
        self.s = value

    @property
    def trade_time_ns(self) -> Optional[int]:
        return self.tn

    @trade_time_ns.setter
    def trade_time_ns(self, value: Optional[int]) -> None:
        self.tn = value

    @property
    def trade_time(self) -> Optional[int]:
        return self.ts

    @trade_time.setter
    def trade_time(self, value: Optional[int]) -> None:
        self.ts = value

    @property
    def trader(self) -> Optional[UserId]:
        return self.u

    @trader.setter
    def trader(self, value: Optional[UserId]) -> None:
        self.u = value

    @property
    def exchange_fill_id(self) -> Optional[str]:
        return self.xid

    @exchange_fill_id.setter
    def exchange_fill_id(self, value: Optional[str]) -> None:
        self.xid = value


class CancelReject(Struct, omit_defaults=True):
    id: OrderId
    xid: str
    rm: Optional[str] = None

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        id: OrderId,
        xid: str,
        rm: Optional[str] = None,
    ):
        return cls(
            id,
            xid,
            rm,
        )

    def __str__(self) -> str:
        return f"CancelReject(id={self.id},xid={self.xid},rm={self.rm})"


class CptyLoginRequest(Struct, omit_defaults=True):
    account: str
    trader: UserId

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        account: str,
        trader: UserId,
    ):
        return cls(
            account,
            trader,
        )

    def __str__(self) -> str:
        return f"CptyLoginRequest(account={self.account},trader={self.trader})"


class ExecutionInfo(Struct, omit_defaults=True):
    """
    Information about a symbol related to its execution route.
    """

    execution_venue: str
    is_delisted: bool
    min_order_quantity: Decimal
    min_order_quantity_unit: MinOrderQuantityUnit
    step_size: Decimal
    tick_size: TickSize
    exchange_symbol: Optional[
        Annotated[
            Optional[str],
            Meta(
                description="If the execution venue has stable symbology, this may be populated"
            ),
        ]
    ] = None
    """
    If the execution venue has stable symbology, this may be populated
    """
    initial_margin: Optional[Decimal] = None
    maintenance_margin: Optional[Decimal] = None

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        execution_venue: str,
        is_delisted: bool,
        min_order_quantity: Decimal,
        min_order_quantity_unit: MinOrderQuantityUnit,
        step_size: Decimal,
        tick_size: TickSize,
        exchange_symbol: Optional[str] = None,
        initial_margin: Optional[Decimal] = None,
        maintenance_margin: Optional[Decimal] = None,
    ):
        return cls(
            execution_venue,
            is_delisted,
            min_order_quantity,
            min_order_quantity_unit,
            step_size,
            tick_size,
            exchange_symbol,
            initial_margin,
            maintenance_margin,
        )

    def __str__(self) -> str:
        return f"ExecutionInfo(execution_venue={self.execution_venue},is_delisted={self.is_delisted},min_order_quantity={self.min_order_quantity},min_order_quantity_unit={self.min_order_quantity_unit},step_size={self.step_size},tick_size={self.tick_size},exchange_symbol={self.exchange_symbol},initial_margin={self.initial_margin},maintenance_margin={self.maintenance_margin})"


class Fill(Struct, omit_defaults=True):
    d: Annotated[OrderDir, Meta(title="dir")]
    id: Annotated[str, Meta(title="fill_id")]
    k: Annotated[FillKind, Meta(title="fill_kind")]
    p: Annotated[Decimal, Meta(title="price")]
    q: Annotated[Decimal, Meta(title="quantity")]
    s: Annotated[str, Meta(title="symbol")]
    tn: Annotated[int, Meta(ge=0, title="trade_time_ns")]
    ts: Annotated[
        int,
        Meta(description="When the cpty claims the trade happened", title="trade_time"),
    ]
    """
    When the cpty claims the trade happened
    """
    x: Annotated[str, Meta(title="execution_venue")]
    a: Optional[Annotated[Optional[str], Meta(title="account")]] = None
    agg: Optional[Annotated[int, Meta(title="is_taker")]] = None
    atn: Optional[Annotated[Optional[int], Meta(title="recv_time_ns")]] = None
    ats: Optional[
        Annotated[
            Optional[int],
            Meta(
                description="When Architect received the fill, if realtime",
                title="recv_time",
            ),
        ]
    ] = None
    """
    When Architect received the fill, if realtime
    """
    f: Optional[Annotated[Optional[Decimal], Meta(title="fee")]] = None
    fu: Optional[
        Annotated[
            Optional[str],
            Meta(
                description="Fee currency, if different from the price currency",
                title="fee_currency",
            ),
        ]
    ] = None
    """
    Fee currency, if different from the price currency
    """
    oid: Optional[Annotated[Optional[OrderId], Meta(title="order_id")]] = None
    u: Optional[Annotated[Optional[UserId], Meta(title="trader")]] = None
    xid: Optional[Annotated[Optional[str], Meta(title="exchange_fill_id")]] = None

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        dir: OrderDir,
        fill_id: str,
        fill_kind: FillKind,
        price: Decimal,
        quantity: Decimal,
        symbol: str,
        trade_time_ns: int,
        trade_time: int,
        execution_venue: str,
        account: Optional[str] = None,
        is_taker: Optional[int] = None,
        recv_time_ns: Optional[int] = None,
        recv_time: Optional[int] = None,
        fee: Optional[Decimal] = None,
        fee_currency: Optional[str] = None,
        order_id: Optional[OrderId] = None,
        trader: Optional[UserId] = None,
        exchange_fill_id: Optional[str] = None,
    ):
        return cls(
            dir,
            fill_id,
            fill_kind,
            price,
            quantity,
            symbol,
            trade_time_ns,
            trade_time,
            execution_venue,
            account,
            is_taker,
            recv_time_ns,
            recv_time,
            fee,
            fee_currency,
            order_id,
            trader,
            exchange_fill_id,
        )

    def __str__(self) -> str:
        return f"Fill(dir={self.d},fill_id={self.id},fill_kind={self.k},price={self.p},quantity={self.q},symbol={self.s},trade_time_ns={self.tn},trade_time={self.ts},execution_venue={self.x},account={self.a},is_taker={self.agg},recv_time_ns={self.atn},recv_time={self.ats},fee={self.f},fee_currency={self.fu},order_id={self.oid},trader={self.u},exchange_fill_id={self.xid})"

    @property
    def dir(self) -> OrderDir:
        return self.d

    @dir.setter
    def dir(self, value: OrderDir) -> None:
        self.d = value

    @property
    def fill_id(self) -> str:
        return self.id

    @fill_id.setter
    def fill_id(self, value: str) -> None:
        self.id = value

    @property
    def fill_kind(self) -> FillKind:
        return self.k

    @fill_kind.setter
    def fill_kind(self, value: FillKind) -> None:
        self.k = value

    @property
    def price(self) -> Decimal:
        return self.p

    @price.setter
    def price(self, value: Decimal) -> None:
        self.p = value

    @property
    def quantity(self) -> Decimal:
        return self.q

    @quantity.setter
    def quantity(self, value: Decimal) -> None:
        self.q = value

    @property
    def symbol(self) -> str:
        return self.s

    @symbol.setter
    def symbol(self, value: str) -> None:
        self.s = value

    @property
    def trade_time_ns(self) -> int:
        return self.tn

    @trade_time_ns.setter
    def trade_time_ns(self, value: int) -> None:
        self.tn = value

    @property
    def trade_time(self) -> int:
        return self.ts

    @trade_time.setter
    def trade_time(self, value: int) -> None:
        self.ts = value

    @property
    def execution_venue(self) -> str:
        return self.x

    @execution_venue.setter
    def execution_venue(self, value: str) -> None:
        self.x = value

    @property
    def account(self) -> Optional[str]:
        return self.a

    @account.setter
    def account(self, value: Optional[str]) -> None:
        self.a = value

    @property
    def is_taker(self) -> Optional[int]:
        return self.agg

    @is_taker.setter
    def is_taker(self, value: Optional[int]) -> None:
        self.agg = value

    @property
    def recv_time_ns(self) -> Optional[int]:
        return self.atn

    @recv_time_ns.setter
    def recv_time_ns(self, value: Optional[int]) -> None:
        self.atn = value

    @property
    def recv_time(self) -> Optional[int]:
        return self.ats

    @recv_time.setter
    def recv_time(self, value: Optional[int]) -> None:
        self.ats = value

    @property
    def fee(self) -> Optional[Decimal]:
        return self.f

    @fee.setter
    def fee(self, value: Optional[Decimal]) -> None:
        self.f = value

    @property
    def fee_currency(self) -> Optional[str]:
        return self.fu

    @fee_currency.setter
    def fee_currency(self, value: Optional[str]) -> None:
        self.fu = value

    @property
    def order_id(self) -> Optional[OrderId]:
        return self.oid

    @order_id.setter
    def order_id(self, value: Optional[OrderId]) -> None:
        self.oid = value

    @property
    def trader(self) -> Optional[UserId]:
        return self.u

    @trader.setter
    def trader(self, value: Optional[UserId]) -> None:
        self.u = value

    @property
    def exchange_fill_id(self) -> Optional[str]:
        return self.xid

    @exchange_fill_id.setter
    def exchange_fill_id(self, value: Optional[str]) -> None:
        self.xid = value


class OptionsContract(Struct, omit_defaults=True):
    expiration: date
    put_or_call: PutOrCall
    strike: Decimal
    ticker: Ticker
    underlying: str
    in_the_money: Optional[bool] = None

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        expiration: date,
        put_or_call: PutOrCall,
        strike: Decimal,
        ticker: Ticker,
        underlying: str,
        in_the_money: Optional[bool] = None,
    ):
        return cls(
            expiration,
            put_or_call,
            strike,
            ticker,
            underlying,
            in_the_money,
        )

    def __str__(self) -> str:
        return f"OptionsContract(expiration={self.expiration},put_or_call={self.put_or_call},strike={self.strike},ticker={self.ticker},underlying={self.underlying},in_the_money={self.in_the_money})"


class OptionsGreeks(Struct, omit_defaults=True):
    delta: Decimal
    expiration: date
    gamma: Decimal
    implied_volatility: Decimal
    put_or_call: PutOrCall
    rho: Decimal
    strike: Decimal
    symbol: str
    theta: Decimal
    underlying: str
    vega: Decimal

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        delta: Decimal,
        expiration: date,
        gamma: Decimal,
        implied_volatility: Decimal,
        put_or_call: PutOrCall,
        rho: Decimal,
        strike: Decimal,
        symbol: str,
        theta: Decimal,
        underlying: str,
        vega: Decimal,
    ):
        return cls(
            delta,
            expiration,
            gamma,
            implied_volatility,
            put_or_call,
            rho,
            strike,
            symbol,
            theta,
            underlying,
            vega,
        )

    def __str__(self) -> str:
        return f"OptionsGreeks(delta={self.delta},expiration={self.expiration},gamma={self.gamma},implied_volatility={self.implied_volatility},put_or_call={self.put_or_call},rho={self.rho},strike={self.strike},symbol={self.symbol},theta={self.theta},underlying={self.underlying},vega={self.vega})"


class OptionsSeriesInfo(Struct, omit_defaults=True):
    derivative_kind: DerivativeKind
    exercise_type: OptionsExerciseType
    expiration_time_of_day: time
    expiration_time_zone: str
    is_cash_settled: bool
    multiplier: Decimal
    options_series: str
    quote_symbol: str
    strikes_by_expiration: Dict[str, List[Decimal]]
    underlying: str
    venue_discriminant: Optional[str] = None

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        derivative_kind: DerivativeKind,
        exercise_type: OptionsExerciseType,
        expiration_time_of_day: time,
        expiration_time_zone: str,
        is_cash_settled: bool,
        multiplier: Decimal,
        options_series: str,
        quote_symbol: str,
        strikes_by_expiration: Dict[str, List[Decimal]],
        underlying: str,
        venue_discriminant: Optional[str] = None,
    ):
        return cls(
            derivative_kind,
            exercise_type,
            expiration_time_of_day,
            expiration_time_zone,
            is_cash_settled,
            multiplier,
            options_series,
            quote_symbol,
            strikes_by_expiration,
            underlying,
            venue_discriminant,
        )

    def __str__(self) -> str:
        return f"OptionsSeriesInfo(derivative_kind={self.derivative_kind},exercise_type={self.exercise_type},expiration_time_of_day={self.expiration_time_of_day},expiration_time_zone={self.expiration_time_zone},is_cash_settled={self.is_cash_settled},multiplier={self.multiplier},options_series={self.options_series},quote_symbol={self.quote_symbol},strikes_by_expiration={self.strikes_by_expiration},underlying={self.underlying},venue_discriminant={self.venue_discriminant})"


class OrderAck(Struct, omit_defaults=True):
    id: Annotated[OrderId, Meta(title="order_id")]
    eid: Optional[Annotated[Optional[str], Meta(title="exchange_order_id")]] = None

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        order_id: OrderId,
        exchange_order_id: Optional[str] = None,
    ):
        return cls(
            order_id,
            exchange_order_id,
        )

    def __str__(self) -> str:
        return f"OrderAck(order_id={self.id},exchange_order_id={self.eid})"

    @property
    def order_id(self) -> OrderId:
        return self.id

    @order_id.setter
    def order_id(self, value: OrderId) -> None:
        self.id = value

    @property
    def exchange_order_id(self) -> Optional[str]:
        return self.eid

    @exchange_order_id.setter
    def exchange_order_id(self, value: Optional[str]) -> None:
        self.eid = value


class OrderCanceled(Struct, omit_defaults=True):
    id: OrderId
    xid: Optional[str] = None

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        id: OrderId,
        xid: Optional[str] = None,
    ):
        return cls(
            id,
            xid,
        )

    def __str__(self) -> str:
        return f"OrderCanceled(id={self.id},xid={self.xid})"


class OrderCanceling(Struct, omit_defaults=True):
    id: OrderId
    xid: Optional[str] = None

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        id: OrderId,
        xid: Optional[str] = None,
    ):
        return cls(
            id,
            xid,
        )

    def __str__(self) -> str:
        return f"OrderCanceling(id={self.id},xid={self.xid})"


class OrderReject(Struct, omit_defaults=True):
    id: OrderId
    r: Annotated[OrderRejectReason, Meta(title="reject_reason")]
    rm: Optional[Annotated[Optional[str], Meta(title="message")]] = None

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        id: OrderId,
        reject_reason: OrderRejectReason,
        message: Optional[str] = None,
    ):
        return cls(
            id,
            reject_reason,
            message,
        )

    def __str__(self) -> str:
        return f"OrderReject(id={self.id},reject_reason={self.r},message={self.rm})"

    @property
    def reject_reason(self) -> OrderRejectReason:
        return self.r

    @reject_reason.setter
    def reject_reason(self, value: OrderRejectReason) -> None:
        self.r = value

    @property
    def message(self) -> Optional[str]:
        return self.rm

    @message.setter
    def message(self, value: Optional[str]) -> None:
        self.rm = value


class SnapshotOrUpdateForAliasKindAndSnapshotOrUpdateForStringAndString1(
    Struct, omit_defaults=True
):
    snapshot: Dict[str, SnapshotOrUpdateForStringAndString]

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        snapshot: Dict[str, SnapshotOrUpdateForStringAndString],
    ):
        return cls(
            snapshot,
        )

    def __str__(self) -> str:
        return f"SnapshotOrUpdateForAliasKindAndSnapshotOrUpdateForStringAndString1(snapshot={self.snapshot})"


Update = List[Union[AliasKind, Optional[SnapshotOrUpdateForStringAndString]]]


class SnapshotOrUpdateForAliasKindAndSnapshotOrUpdateForStringAndString2(
    Struct, omit_defaults=True
):
    updates: List[Update]

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        updates: List[Update],
    ):
        return cls(
            updates,
        )

    def __str__(self) -> str:
        return f"SnapshotOrUpdateForAliasKindAndSnapshotOrUpdateForStringAndString2(updates={self.updates})"


SnapshotOrUpdateForAliasKindAndSnapshotOrUpdateForStringAndString = Union[
    SnapshotOrUpdateForAliasKindAndSnapshotOrUpdateForStringAndString1,
    SnapshotOrUpdateForAliasKindAndSnapshotOrUpdateForStringAndString2,
]


class SnapshotOrUpdateForStringAndOptionsSeriesInfo1(Struct, omit_defaults=True):
    snapshot: Dict[str, OptionsSeriesInfo]

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        snapshot: Dict[str, OptionsSeriesInfo],
    ):
        return cls(
            snapshot,
        )

    def __str__(self) -> str:
        return (
            f"SnapshotOrUpdateForStringAndOptionsSeriesInfo1(snapshot={self.snapshot})"
        )


Update1 = List[Union[str, Optional[OptionsSeriesInfo]]]


class SnapshotOrUpdateForStringAndOptionsSeriesInfo2(Struct, omit_defaults=True):
    updates: List[Update1]

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        updates: List[Update1],
    ):
        return cls(
            updates,
        )

    def __str__(self) -> str:
        return f"SnapshotOrUpdateForStringAndOptionsSeriesInfo2(updates={self.updates})"


SnapshotOrUpdateForStringAndOptionsSeriesInfo = Union[
    SnapshotOrUpdateForStringAndOptionsSeriesInfo1,
    SnapshotOrUpdateForStringAndOptionsSeriesInfo2,
]


class SnapshotOrUpdateForStringAndSnapshotOrUpdateForStringAndProductCatalogInfo1(
    Struct
):
    snapshot: Dict[str, SnapshotOrUpdateForStringAndProductCatalogInfo]

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        snapshot: Dict[str, SnapshotOrUpdateForStringAndProductCatalogInfo],
    ):
        return cls(
            snapshot,
        )

    def __str__(self) -> str:
        return f"SnapshotOrUpdateForStringAndSnapshotOrUpdateForStringAndProductCatalogInfo1(snapshot={self.snapshot})"


Update4 = List[Union[str, Optional[SnapshotOrUpdateForStringAndProductCatalogInfo]]]


class SnapshotOrUpdateForStringAndSnapshotOrUpdateForStringAndProductCatalogInfo2(
    Struct
):
    updates: List[Update4]

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        updates: List[Update4],
    ):
        return cls(
            updates,
        )

    def __str__(self) -> str:
        return f"SnapshotOrUpdateForStringAndSnapshotOrUpdateForStringAndProductCatalogInfo2(updates={self.updates})"


SnapshotOrUpdateForStringAndSnapshotOrUpdateForStringAndProductCatalogInfo = Union[
    SnapshotOrUpdateForStringAndSnapshotOrUpdateForStringAndProductCatalogInfo1,
    SnapshotOrUpdateForStringAndSnapshotOrUpdateForStringAndProductCatalogInfo2,
]


class Account(Struct, omit_defaults=True):
    id: str
    name: AccountName

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        id: str,
        name: AccountName,
    ):
        return cls(
            id,
            name,
        )

    def __str__(self) -> str:
        return f"Account(id={self.id},name={self.name})"


class FutureSpread(Struct, omit_defaults=True):
    legs: List[SpreadLeg]
    product_type: Literal["FutureSpread"]

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        legs: List[SpreadLeg],
        product_type: Literal["FutureSpread"],
    ):
        return cls(
            legs,
            product_type,
        )

    def __str__(self) -> str:
        return f"FutureSpread(legs={self.legs},product_type={self.product_type})"


class Option(Struct, omit_defaults=True):
    instance: OptionsSeriesInstance
    product_type: Literal["Option"]
    series: str

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        instance: OptionsSeriesInstance,
        product_type: Literal["Option"],
        series: str,
    ):
        return cls(
            instance,
            product_type,
            series,
        )

    def __str__(self) -> str:
        return f"Option(instance={self.instance},product_type={self.product_type},series={self.series})"


class SnapshotOrUpdateForStringAndExecutionInfo1(Struct, omit_defaults=True):
    snapshot: Dict[str, ExecutionInfo]

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        snapshot: Dict[str, ExecutionInfo],
    ):
        return cls(
            snapshot,
        )

    def __str__(self) -> str:
        return f"SnapshotOrUpdateForStringAndExecutionInfo1(snapshot={self.snapshot})"


Update5 = List[Union[str, Optional[ExecutionInfo]]]


class SnapshotOrUpdateForStringAndExecutionInfo2(Struct, omit_defaults=True):
    updates: List[Update5]

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        updates: List[Update5],
    ):
        return cls(
            updates,
        )

    def __str__(self) -> str:
        return f"SnapshotOrUpdateForStringAndExecutionInfo2(updates={self.updates})"


SnapshotOrUpdateForStringAndExecutionInfo = Union[
    SnapshotOrUpdateForStringAndExecutionInfo1,
    SnapshotOrUpdateForStringAndExecutionInfo2,
]


class Enumerated(Struct, omit_defaults=True):
    outcome: Outcome

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        outcome: Outcome,
    ):
        return cls(
            outcome,
        )

    def __str__(self) -> str:
        return f"Enumerated(outcome={self.outcome})"


class EventContractSeriesInstance1(Struct, omit_defaults=True):
    Enumerated: Enumerated

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        Enumerated: Enumerated,
    ):
        return cls(
            Enumerated,
        )

    def __str__(self) -> str:
        return f"EventContractSeriesInstance1(Enumerated={self.Enumerated})"


EventContractSeriesInstance = Union[
    EventContractSeriesInstance1, EventContractSeriesInstance2
]


class AccountWithPermissions(Struct, omit_defaults=True):
    account: Account
    permissions: AccountPermissions
    trader: UserId

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        account: Account,
        permissions: AccountPermissions,
        trader: UserId,
    ):
        return cls(
            account,
            permissions,
            trader,
        )

    def __str__(self) -> str:
        return f"AccountWithPermissions(account={self.account},permissions={self.permissions},trader={self.trader})"


class SnapshotOrUpdateForStringAndSnapshotOrUpdateForStringAndExecutionInfo1(
    Struct, omit_defaults=True
):
    snapshot: Dict[str, SnapshotOrUpdateForStringAndExecutionInfo]

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        snapshot: Dict[str, SnapshotOrUpdateForStringAndExecutionInfo],
    ):
        return cls(
            snapshot,
        )

    def __str__(self) -> str:
        return f"SnapshotOrUpdateForStringAndSnapshotOrUpdateForStringAndExecutionInfo1(snapshot={self.snapshot})"


Update3 = List[Union[str, Optional[SnapshotOrUpdateForStringAndExecutionInfo]]]


class SnapshotOrUpdateForStringAndSnapshotOrUpdateForStringAndExecutionInfo2(
    Struct, omit_defaults=True
):
    updates: List[Update3]

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        updates: List[Update3],
    ):
        return cls(
            updates,
        )

    def __str__(self) -> str:
        return f"SnapshotOrUpdateForStringAndSnapshotOrUpdateForStringAndExecutionInfo2(updates={self.updates})"


SnapshotOrUpdateForStringAndSnapshotOrUpdateForStringAndExecutionInfo = Union[
    SnapshotOrUpdateForStringAndSnapshotOrUpdateForStringAndExecutionInfo1,
    SnapshotOrUpdateForStringAndSnapshotOrUpdateForStringAndExecutionInfo2,
]


class EventContract(Struct, omit_defaults=True):
    instance: EventContractSeriesInstance
    product_type: Literal["EventContract"]
    series: str

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        instance: EventContractSeriesInstance,
        product_type: Literal["EventContract"],
        series: str,
    ):
        return cls(
            instance,
            product_type,
            series,
        )

    def __str__(self) -> str:
        return f"EventContract(instance={self.instance},product_type={self.product_type},series={self.series})"


ProductType = Union[
    Fiat,
    Commodity,
    Crypto,
    Equity,
    Index,
    Future,
    FutureSpread,
    Perpetual,
    Option,
    EventContract,
    Unknown,
]


class ProductInfo(Struct, omit_defaults=True):
    product_type: ProductType
    price_display_format: Optional[PriceDisplayFormat] = None
    primary_venue: Optional[str] = None

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        product_type: ProductType,
        price_display_format: Optional[PriceDisplayFormat] = None,
        primary_venue: Optional[str] = None,
    ):
        return cls(
            product_type,
            price_display_format,
            primary_venue,
        )

    def __str__(self) -> str:
        return f"ProductInfo(product_type={self.product_type},price_display_format={self.price_display_format},primary_venue={self.primary_venue})"


class SnapshotOrUpdateForStringAndProductInfo1(Struct, omit_defaults=True):
    snapshot: Dict[str, ProductInfo]

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        snapshot: Dict[str, ProductInfo],
    ):
        return cls(
            snapshot,
        )

    def __str__(self) -> str:
        return f"SnapshotOrUpdateForStringAndProductInfo1(snapshot={self.snapshot})"


Update2 = List[Union[str, Optional[ProductInfo]]]


class SnapshotOrUpdateForStringAndProductInfo2(Struct, omit_defaults=True):
    updates: List[Update2]

    # Constructor that takes all field titles as arguments for convenience
    @classmethod
    def new(
        cls,
        updates: List[Update2],
    ):
        return cls(
            updates,
        )

    def __str__(self) -> str:
        return f"SnapshotOrUpdateForStringAndProductInfo2(updates={self.updates})"


SnapshotOrUpdateForStringAndProductInfo = Union[
    SnapshotOrUpdateForStringAndProductInfo1, SnapshotOrUpdateForStringAndProductInfo2
]
