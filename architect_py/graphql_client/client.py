# Generated by ariadne-codegen
# Source: queries.graphql

from datetime import datetime
from decimal import Decimal
from typing import Any, AsyncIterator, Dict, List, Optional, Union

from architect_py.scalars import OrderDir, convert_datetime_to_utc_str, serialize

from .base_model import UNSET, UnsetType
from .cancel_all_orders import CancelAllOrders, CancelAllOrdersOms
from .cancel_order import CancelOrder, CancelOrderOms
from .create_jwt import CreateJwt, CreateJwtUser
from .enums import CandleWidth, OrderType, TimeInForce
from .future_series import FutureSeries, FutureSeriesSymbology
from .get_account_summaries import GetAccountSummaries, GetAccountSummariesFolio
from .get_account_summary import GetAccountSummary, GetAccountSummaryFolio
from .get_all_open_orders import GetAllOpenOrders, GetAllOpenOrdersOms
from .get_book_snapshot import GetBookSnapshot, GetBookSnapshotMarketdata
from .get_execution_info import GetExecutionInfo, GetExecutionInfoSymbology
from .get_fills import GetFills, GetFillsFolio
from .get_first_notice_date import GetFirstNoticeDate, GetFirstNoticeDateSymbology
from .get_historical_orders import GetHistoricalOrders, GetHistoricalOrdersFolio
from .get_main_execution_venue import (
    GetMainExecutionVenue,
    GetMainExecutionVenueSymbology,
)
from .get_market_snapshot import GetMarketSnapshot, GetMarketSnapshotMarketdata
from .get_market_snapshots import GetMarketSnapshots, GetMarketSnapshotsMarketdata
from .get_open_orders import GetOpenOrders, GetOpenOrdersOms
from .get_product_info import GetProductInfo, GetProductInfoSymbology
from .get_product_infos import GetProductInfos, GetProductInfosSymbology
from .juniper_base_client import JuniperBaseClient
from .place_order import PlaceOrder, PlaceOrderOms
from .search_symbols_request import SearchSymbolsRequest, SearchSymbolsRequestSymbology
from .subscribe_candles import SubscribeCandles, SubscribeCandlesCandles
from .subscribe_orderflow import (
    SubscribeOrderflow,
    SubscribeOrderflowOrderflowAberrantFill,
    SubscribeOrderflowOrderflowCancel,
    SubscribeOrderflowOrderflowCancelReject,
    SubscribeOrderflowOrderflowFill,
    SubscribeOrderflowOrderflowGqlOrderReject,
    SubscribeOrderflowOrderflowOrder,
    SubscribeOrderflowOrderflowOrderAck,
    SubscribeOrderflowOrderflowOrderCanceled,
    SubscribeOrderflowOrderflowOrderCanceling,
    SubscribeOrderflowOrderflowOrderOut,
    SubscribeOrderflowOrderflowOrderStale,
)
from .subscribe_trades import SubscribeTrades, SubscribeTradesTrades


def gql(q: str) -> str:
    return q


class GraphQLClient(JuniperBaseClient):
    async def search_symbols_request(
        self,
        sort_by_volume_desc: bool,
        search_string: Union[Optional[str], UnsetType] = UNSET,
        execution_venue: Union[Optional[str], UnsetType] = UNSET,
        marketdata_venue: Union[Optional[str], UnsetType] = UNSET,
        underlying: Union[Optional[str], UnsetType] = UNSET,
        max_results: Union[Optional[int], UnsetType] = UNSET,
        results_offset: Union[Optional[int], UnsetType] = UNSET,
        **kwargs: Any
    ) -> SearchSymbolsRequestSymbology:
        query = gql(
            """
            query SearchSymbolsRequest($searchString: String, $executionVenue: ExecutionVenue, $marketdataVenue: MarketdataVenue, $underlying: String, $maxResults: Int, $resultsOffset: Int, $sortByVolumeDesc: Boolean!) {
              symbology {
                searchSymbols(
                  searchString: $searchString
                  executionVenue: $executionVenue
                  marketdataVenue: $marketdataVenue
                  underlying: $underlying
                  maxResults: $maxResults
                  resultsOffset: $resultsOffset
                  sortByVolumeDesc: $sortByVolumeDesc
                )
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "searchString": search_string,
            "executionVenue": execution_venue,
            "marketdataVenue": marketdata_venue,
            "underlying": underlying,
            "maxResults": max_results,
            "resultsOffset": results_offset,
            "sortByVolumeDesc": sort_by_volume_desc,
        }
        response = await self.execute(
            query=query,
            operation_name="SearchSymbolsRequest",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return SearchSymbolsRequest.model_validate(data).symbology

    async def get_product_info(
        self, symbol: str, **kwargs: Any
    ) -> GetProductInfoSymbology:
        query = gql(
            """
            query GetProductInfo($symbol: String!) {
              symbology {
                productInfo(symbol: $symbol) {
                  ...ProductInfoFields
                }
              }
            }

            fragment ProductInfoFields on ProductInfo {
              __typename
              symbol
              productType
              underlying
              multiplier
              derivativeKind
              firstNoticeDate
            }
            """
        )
        variables: Dict[str, object] = {"symbol": symbol}
        response = await self.execute(
            query=query, operation_name="GetProductInfo", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return GetProductInfo.model_validate(data).symbology

    async def get_product_infos(
        self, symbols: List[str], **kwargs: Any
    ) -> GetProductInfosSymbology:
        query = gql(
            """
            query GetProductInfos($symbols: [String!]!) {
              symbology {
                productInfos(symbols: $symbols) {
                  ...ProductInfoFields
                }
              }
            }

            fragment ProductInfoFields on ProductInfo {
              __typename
              symbol
              productType
              underlying
              multiplier
              derivativeKind
              firstNoticeDate
            }
            """
        )
        variables: Dict[str, object] = {"symbols": symbols}
        response = await self.execute(
            query=query, operation_name="GetProductInfos", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return GetProductInfos.model_validate(data).symbology

    async def get_first_notice_date(
        self, symbol: str, **kwargs: Any
    ) -> GetFirstNoticeDateSymbology:
        query = gql(
            """
            query GetFirstNoticeDate($symbol: String!) {
              symbology {
                productInfo(symbol: $symbol) {
                  firstNoticeDate
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"symbol": symbol}
        response = await self.execute(
            query=query,
            operation_name="GetFirstNoticeDate",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetFirstNoticeDate.model_validate(data).symbology

    async def future_series(
        self, series_symbol: str, **kwargs: Any
    ) -> FutureSeriesSymbology:
        query = gql(
            """
            query FutureSeries($seriesSymbol: String!) {
              symbology {
                futuresSeries(seriesSymbol: $seriesSymbol)
              }
            }
            """
        )
        variables: Dict[str, object] = {"seriesSymbol": series_symbol}
        response = await self.execute(
            query=query, operation_name="FutureSeries", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return FutureSeries.model_validate(data).symbology

    async def get_main_execution_venue(
        self, symbol: str, **kwargs: Any
    ) -> GetMainExecutionVenueSymbology:
        query = gql(
            """
            query getMainExecutionVenue($symbol: String!) {
              symbology {
                getMainExecutionVenue(symbol: $symbol)
              }
            }
            """
        )
        variables: Dict[str, object] = {"symbol": symbol}
        response = await self.execute(
            query=query,
            operation_name="getMainExecutionVenue",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetMainExecutionVenue.model_validate(data).symbology

    async def get_execution_info(
        self, symbol: str, execution_venue: str, **kwargs: Any
    ) -> GetExecutionInfoSymbology:
        query = gql(
            """
            query GetExecutionInfo($symbol: String!, $executionVenue: ExecutionVenue!) {
              symbology {
                executionInfo(symbol: $symbol, executionVenue: $executionVenue) {
                  symbol
                  executionVenue
                  tickSize
                  stepSize
                  minOrderQuantity
                  minOrderQuantityUnit
                  isDelisted
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "symbol": symbol,
            "executionVenue": execution_venue,
        }
        response = await self.execute(
            query=query,
            operation_name="GetExecutionInfo",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetExecutionInfo.model_validate(data).symbology

    async def get_market_snapshot(
        self, venue: str, symbol: str, **kwargs: Any
    ) -> GetMarketSnapshotMarketdata:
        query = gql(
            """
            query GetMarketSnapshot($venue: MarketdataVenue!, $symbol: String!) {
              marketdata {
                ticker(venue: $venue, symbol: $symbol) {
                  ...MarketTickerFields
                }
              }
            }

            fragment MarketTickerFields on Ticker {
              symbol
              timestamp
              bidPrice
              bidSize
              askPrice
              askSize
              lastPrice
              lastSize
            }
            """
        )
        variables: Dict[str, object] = {"venue": venue, "symbol": symbol}
        response = await self.execute(
            query=query,
            operation_name="GetMarketSnapshot",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetMarketSnapshot.model_validate(data).marketdata

    async def get_market_snapshots(
        self,
        venue: str,
        symbols: Union[Optional[List[str]], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetMarketSnapshotsMarketdata:
        query = gql(
            """
            query GetMarketSnapshots($venue: MarketdataVenue!, $symbols: [String!]) {
              marketdata {
                tickers(venue: $venue, symbols: $symbols) {
                  ...MarketTickerFields
                }
              }
            }

            fragment MarketTickerFields on Ticker {
              symbol
              timestamp
              bidPrice
              bidSize
              askPrice
              askSize
              lastPrice
              lastSize
            }
            """
        )
        variables: Dict[str, object] = {"venue": venue, "symbols": symbols}
        response = await self.execute(
            query=query,
            operation_name="GetMarketSnapshots",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetMarketSnapshots.model_validate(data).marketdata

    async def get_account_summary(
        self,
        account: str,
        venue: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetAccountSummaryFolio:
        query = gql(
            """
            query GetAccountSummary($venue: ExecutionVenue, $account: String!) {
              folio {
                accountSummary(venue: $venue, account: $account) {
                  ...AccountSummaryFields
                }
              }
            }

            fragment AccountSummaryFields on AccountSummary {
              account
              timestamp
              balances {
                product
                balance
              }
              positions {
                symbol
                quantity
                tradeTime
                costBasis
                breakEvenPrice
                liquidationPrice
              }
              unrealizedPnl
              realizedPnl
              equity
              yesterdayEquity
              cashExcess
              purchasingPower
              totalMargin
              positionMargin
            }
            """
        )
        variables: Dict[str, object] = {"venue": venue, "account": account}
        response = await self.execute(
            query=query,
            operation_name="GetAccountSummary",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetAccountSummary.model_validate(data).folio

    async def get_account_summaries(
        self,
        venue: Union[Optional[str], UnsetType] = UNSET,
        trader: Union[Optional[str], UnsetType] = UNSET,
        accounts: Union[Optional[List[str]], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetAccountSummariesFolio:
        query = gql(
            """
            query GetAccountSummaries($venue: ExecutionVenue, $trader: String, $accounts: [String!]) {
              folio {
                accountSummaries(venue: $venue, trader: $trader, accounts: $accounts) {
                  ...AccountSummaryFields
                }
              }
            }

            fragment AccountSummaryFields on AccountSummary {
              account
              timestamp
              balances {
                product
                balance
              }
              positions {
                symbol
                quantity
                tradeTime
                costBasis
                breakEvenPrice
                liquidationPrice
              }
              unrealizedPnl
              realizedPnl
              equity
              yesterdayEquity
              cashExcess
              purchasingPower
              totalMargin
              positionMargin
            }
            """
        )
        variables: Dict[str, object] = {
            "venue": venue,
            "trader": trader,
            "accounts": accounts,
        }
        response = await self.execute(
            query=query,
            operation_name="GetAccountSummaries",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetAccountSummaries.model_validate(data).folio

    async def get_open_orders(
        self,
        venue: Union[Optional[str], UnsetType] = UNSET,
        account: Union[Optional[str], UnsetType] = UNSET,
        trader: Union[Optional[str], UnsetType] = UNSET,
        symbol: Union[Optional[str], UnsetType] = UNSET,
        parent_order_id: Union[Optional[str], UnsetType] = UNSET,
        order_ids: Union[Optional[List[str]], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetOpenOrdersOms:
        query = gql(
            """
            query GetOpenOrders($venue: ExecutionVenue, $account: String, $trader: String, $symbol: String, $parentOrderId: OrderId, $orderIds: [OrderId!]) {
              oms {
                openOrders(
                  venue: $venue
                  account: $account
                  trader: $trader
                  symbol: $symbol
                  parentOrderId: $parentOrderId
                  orderIds: $orderIds
                ) {
                  ...OrderFields
                }
              }
            }

            fragment OrderFields on Order {
              id
              parentId
              recvTime
              status
              rejectReason
              symbol
              trader
              account
              dir
              quantity
              filledQuantity
              averageFillPrice
              orderType
              limitPrice
              postOnly
              triggerPrice
              timeInForce
              goodTilDate
              source
              executionVenue
            }
            """
        )
        variables: Dict[str, object] = {
            "venue": venue,
            "account": account,
            "trader": trader,
            "symbol": symbol,
            "parentOrderId": parent_order_id,
            "orderIds": order_ids,
        }
        response = await self.execute(
            query=query, operation_name="GetOpenOrders", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return GetOpenOrders.model_validate(data).oms

    async def get_all_open_orders(self, **kwargs: Any) -> GetAllOpenOrdersOms:
        query = gql(
            """
            query GetAllOpenOrders {
              oms {
                openOrders {
                  ...OrderFields
                }
              }
            }

            fragment OrderFields on Order {
              id
              parentId
              recvTime
              status
              rejectReason
              symbol
              trader
              account
              dir
              quantity
              filledQuantity
              averageFillPrice
              orderType
              limitPrice
              postOnly
              triggerPrice
              timeInForce
              goodTilDate
              source
              executionVenue
            }
            """
        )
        variables: Dict[str, object] = {}
        response = await self.execute(
            query=query,
            operation_name="GetAllOpenOrders",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetAllOpenOrders.model_validate(data).oms

    async def get_historical_orders(
        self,
        from_inclusive: datetime,
        to_exclusive: datetime,
        venue: Union[Optional[str], UnsetType] = UNSET,
        account: Union[Optional[str], UnsetType] = UNSET,
        parent_order_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetHistoricalOrdersFolio:
        query = gql(
            """
            query GetHistoricalOrders($venue: ExecutionVenue, $account: String, $parentOrderId: OrderId, $fromInclusive: DateTime!, $toExclusive: DateTime!) {
              folio {
                historicalOrders(
                  venue: $venue
                  account: $account
                  parentOrderId: $parentOrderId
                  fromInclusive: $fromInclusive
                  toExclusive: $toExclusive
                ) {
                  ...OrderFields
                }
              }
            }

            fragment OrderFields on Order {
              id
              parentId
              recvTime
              status
              rejectReason
              symbol
              trader
              account
              dir
              quantity
              filledQuantity
              averageFillPrice
              orderType
              limitPrice
              postOnly
              triggerPrice
              timeInForce
              goodTilDate
              source
              executionVenue
            }
            """
        )
        variables: Dict[str, object] = {
            "venue": venue,
            "account": account,
            "parentOrderId": parent_order_id,
            "fromInclusive": convert_datetime_to_utc_str(from_inclusive),
            "toExclusive": convert_datetime_to_utc_str(to_exclusive),
        }
        response = await self.execute(
            query=query,
            operation_name="GetHistoricalOrders",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetHistoricalOrders.model_validate(data).folio

    async def get_fills(
        self,
        venue: Union[Optional[str], UnsetType] = UNSET,
        account: Union[Optional[str], UnsetType] = UNSET,
        order_id: Union[Optional[str], UnsetType] = UNSET,
        from_inclusive: Union[Optional[datetime], UnsetType] = UNSET,
        to_exclusive: Union[Optional[datetime], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetFillsFolio:
        query = gql(
            """
            query GetFills($venue: ExecutionVenue, $account: String, $orderId: OrderId, $fromInclusive: DateTime, $toExclusive: DateTime) {
              folio {
                historicalFills(
                  venue: $venue
                  account: $account
                  orderId: $orderId
                  fromInclusive: $fromInclusive
                  toExclusive: $toExclusive
                ) {
                  fills {
                    fillId
                    fillKind
                    executionVenue
                    exchangeFillId
                    orderId
                    trader
                    account
                    symbol
                    dir
                    quantity
                    price
                    recvTime
                    tradeTime
                  }
                  aberrantFills {
                    fillId
                    fillKind
                    executionVenue
                    exchangeFillId
                    orderId
                    trader
                    account
                    symbol
                    dir
                    quantity
                    price
                    recvTime
                    tradeTime
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "venue": venue,
            "account": account,
            "orderId": order_id,
            "fromInclusive": convert_datetime_to_utc_str(from_inclusive),
            "toExclusive": convert_datetime_to_utc_str(to_exclusive),
        }
        response = await self.execute(
            query=query, operation_name="GetFills", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return GetFills.model_validate(data).folio

    async def get_book_snapshot(
        self, venue: str, symbol: str, **kwargs: Any
    ) -> GetBookSnapshotMarketdata:
        query = gql(
            """
            query GetBookSnapshot($venue: MarketdataVenue!, $symbol: String!) {
              marketdata {
                l2BookSnapshot(venue: $venue, symbol: $symbol) {
                  timestamp
                  bids {
                    price
                    size
                  }
                  asks {
                    price
                    size
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"venue": venue, "symbol": symbol}
        response = await self.execute(
            query=query, operation_name="GetBookSnapshot", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return GetBookSnapshot.model_validate(data).marketdata

    async def subscribe_trades(
        self, venue: str, symbol: str, **kwargs: Any
    ) -> AsyncIterator[SubscribeTradesTrades]:
        query = gql(
            """
            subscription SubscribeTrades($venue: MarketdataVenue!, $symbol: String!) {
              trades(venue: $venue, symbol: $symbol) {
                timestamp
                direction
                price
                size
              }
            }
            """
        )
        variables: Dict[str, object] = {"venue": venue, "symbol": symbol}
        async for data in self.execute_ws(
            query=query, operation_name="SubscribeTrades", variables=variables, **kwargs
        ):
            yield SubscribeTrades.model_validate(data).trades

    async def subscribe_candles(
        self,
        venue: str,
        symbol: str,
        widths: Union[Optional[List[CandleWidth]], UnsetType] = UNSET,
        **kwargs: Any
    ) -> AsyncIterator[SubscribeCandlesCandles]:
        query = gql(
            """
            subscription SubscribeCandles($venue: MarketdataVenue!, $symbol: String!, $widths: [CandleWidth!]) {
              candles(venue: $venue, symbol: $symbol, candleWidths: $widths) {
                ...CandleFields
              }
            }

            fragment CandleFields on Candle {
              timestamp
              width
              open
              high
              low
              close
              volume
            }
            """
        )
        variables: Dict[str, object] = {
            "venue": venue,
            "symbol": symbol,
            "widths": widths,
        }
        async for data in self.execute_ws(
            query=query,
            operation_name="SubscribeCandles",
            variables=variables,
            **kwargs
        ):
            yield SubscribeCandles.model_validate(data).candles

    async def cancel_order(self, order_id: str, **kwargs: Any) -> CancelOrderOms:
        query = gql(
            """
            mutation CancelOrder($orderId: OrderId!) {
              oms {
                cancelOrder(orderId: $orderId) {
                  cancelId
                  orderId
                  recvTime
                  status
                  rejectReason
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"orderId": order_id}
        response = await self.execute(
            query=query, operation_name="CancelOrder", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return CancelOrder.model_validate(data).oms

    async def cancel_all_orders(self, **kwargs: Any) -> CancelAllOrdersOms:
        query = gql(
            """
            mutation CancelAllOrders {
              oms {
                cancelAllOrders
              }
            }
            """
        )
        variables: Dict[str, object] = {}
        response = await self.execute(
            query=query, operation_name="CancelAllOrders", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return CancelAllOrders.model_validate(data).oms

    async def place_order(
        self,
        symbol: str,
        dir: OrderDir,
        quantity: Decimal,
        order_type: OrderType,
        time_in_force: TimeInForce,
        id: Union[Optional[str], UnsetType] = UNSET,
        trader: Union[Optional[str], UnsetType] = UNSET,
        account: Union[Optional[str], UnsetType] = UNSET,
        limit_price: Union[Optional[Decimal], UnsetType] = UNSET,
        post_only: Union[Optional[bool], UnsetType] = UNSET,
        trigger_price: Union[Optional[Decimal], UnsetType] = UNSET,
        good_til_date: Union[Optional[datetime], UnsetType] = UNSET,
        execution_venue: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> PlaceOrderOms:
        query = gql(
            """
            mutation PlaceOrder($id: OrderId, $symbol: String!, $dir: Dir!, $quantity: Decimal!, $trader: String, $account: String, $orderType: OrderType!, $limitPrice: Decimal, $postOnly: Boolean, $triggerPrice: Decimal, $timeInForce: TimeInForce!, $goodTilDate: DateTime, $executionVenue: ExecutionVenue) {
              oms {
                placeOrder(
                  id: $id
                  symbol: $symbol
                  dir: $dir
                  quantity: $quantity
                  trader: $trader
                  account: $account
                  orderType: $orderType
                  limitPrice: $limitPrice
                  postOnly: $postOnly
                  triggerPrice: $triggerPrice
                  timeInForce: $timeInForce
                  goodTilDate: $goodTilDate
                  executionVenue: $executionVenue
                ) {
                  ...OrderFields
                }
              }
            }

            fragment OrderFields on Order {
              id
              parentId
              recvTime
              status
              rejectReason
              symbol
              trader
              account
              dir
              quantity
              filledQuantity
              averageFillPrice
              orderType
              limitPrice
              postOnly
              triggerPrice
              timeInForce
              goodTilDate
              source
              executionVenue
            }
            """
        )
        variables: Dict[str, object] = {
            "id": id,
            "symbol": symbol,
            "dir": serialize(dir),
            "quantity": quantity,
            "trader": trader,
            "account": account,
            "orderType": order_type,
            "limitPrice": limit_price,
            "postOnly": post_only,
            "triggerPrice": trigger_price,
            "timeInForce": time_in_force,
            "goodTilDate": convert_datetime_to_utc_str(good_til_date),
            "executionVenue": execution_venue,
        }
        response = await self.execute(
            query=query, operation_name="PlaceOrder", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return PlaceOrder.model_validate(data).oms

    async def subscribe_orderflow(self, **kwargs: Any) -> AsyncIterator[
        Union[
            SubscribeOrderflowOrderflowOrder,
            SubscribeOrderflowOrderflowOrderAck,
            SubscribeOrderflowOrderflowGqlOrderReject,
            SubscribeOrderflowOrderflowOrderOut,
            SubscribeOrderflowOrderflowOrderStale,
            SubscribeOrderflowOrderflowCancel,
            SubscribeOrderflowOrderflowCancelReject,
            SubscribeOrderflowOrderflowOrderCanceling,
            SubscribeOrderflowOrderflowOrderCanceled,
            SubscribeOrderflowOrderflowFill,
            SubscribeOrderflowOrderflowAberrantFill,
        ]
    ]:
        query = gql(
            """
            subscription SubscribeOrderflow {
              orderflow {
                __typename
                ... on Order {
                  ...OrderFields
                }
                ... on OrderAck {
                  orderId
                }
                ... on OrderCanceled {
                  orderId
                  cancelId
                }
                ... on GqlOrderReject {
                  orderId
                  reason
                  message
                }
                ... on CancelReject {
                  orderId
                  message
                }
                ... on Fill {
                  fillOrderId: orderId
                  fillId
                  fillKind
                  executionVenue
                  exchangeFillId
                  symbol
                  dir
                  quantity
                  price
                  recvTime
                  tradeTime
                }
                ... on OrderOut {
                  orderId
                }
                ... on OrderStale {
                  orderId
                }
              }
            }

            fragment OrderFields on Order {
              id
              parentId
              recvTime
              status
              rejectReason
              symbol
              trader
              account
              dir
              quantity
              filledQuantity
              averageFillPrice
              orderType
              limitPrice
              postOnly
              triggerPrice
              timeInForce
              goodTilDate
              source
              executionVenue
            }
            """
        )
        variables: Dict[str, object] = {}
        async for data in self.execute_ws(
            query=query,
            operation_name="SubscribeOrderflow",
            variables=variables,
            **kwargs
        ):
            yield SubscribeOrderflow.model_validate(data).orderflow

    async def create_jwt(self, **kwargs: Any) -> CreateJwtUser:
        query = gql(
            """
            mutation CreateJwt {
              user {
                createJwt
              }
            }
            """
        )
        variables: Dict[str, object] = {}
        response = await self.execute(
            query=query, operation_name="CreateJwt", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return CreateJwt.model_validate(data).user
